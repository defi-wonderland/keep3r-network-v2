{
  "language": "Solidity",
  "sources": {
    "@defi-wonderland/solidity-utils/solidity/interfaces/IBaseErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.8 <0.9.0;\n\ninterface IBaseErrors {\n    /// @notice Thrown if an address is invalid\n    error InvalidAddress();\n\n    /// @notice Thrown if an amount is invalid\n    error InvalidAmount();\n\n    /// @notice Thrown if the lengths of a set of lists mismatch\n    error LengthMismatch();\n\n    /// @notice Thrown if an address is the zero address\n    error ZeroAddress();\n\n    /// @notice Thrown if an amount is zero\n    error ZeroAmount();\n}\n"
    },
    "@defi-wonderland/solidity-utils/solidity/interfaces/IDustCollector.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.8 <0.9.0;\n\nimport {IGovernable} from './IGovernable.sol';\nimport {IBaseErrors} from './IBaseErrors.sol';\n\n/// @title DustCollector interface\ninterface IDustCollector is IBaseErrors, IGovernable {\n    // STATE VARIABLES\n\n    /// @return _ethAddress Address used to trigger a native token transfer\n    // solhint-disable-next-line func-name-mixedcase\n    function ETH_ADDRESS() external view returns (address _ethAddress);\n\n    // EVENTS\n\n    /// @notice Emitted when dust is sent\n    /// @param _to The address which wil received the funds\n    /// @param _token The token that will be transferred\n    /// @param _amount The amount of the token that will be transferred\n    event DustSent(address _token, uint256 _amount, address _to);\n\n    // FUNCTIONS\n\n    /// @notice Allows an authorized user to transfer the tokens or eth that may have been left in a contract\n    /// @param _token The token that will be transferred\n    /// @param _amount The amont of the token that will be transferred\n    /// @param _to The address that will receive the idle funds\n    function sendDust(address _token, uint256 _amount, address _to) external;\n}\n"
    },
    "@defi-wonderland/solidity-utils/solidity/interfaces/IGovernable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.8 <0.9.0;\n\nimport {IBaseErrors} from './IBaseErrors.sol';\n\n/// @title Governable interface\ninterface IGovernable is IBaseErrors {\n    // STATE VARIABLES\n\n    /// @return _governor Address of the current governor\n    function governor() external view returns (address _governor);\n\n    /// @return _pendingGovernor Address of the current pending governor\n    function pendingGovernor() external view returns (address _pendingGovernor);\n\n    // EVENTS\n\n    /// @notice Emitted when a new pending governor is set\n    /// @param _governor Address of the current governor\n    /// @param _pendingGovernor Address of the proposed next governor\n    event PendingGovernorSet(address _governor, address _pendingGovernor);\n\n    /// @notice Emitted when a new governor is set\n    /// @param _newGovernor Address of the new governor\n    event PendingGovernorAccepted(address _newGovernor);\n\n    // ERRORS\n\n    /// @notice Thrown if a non-governor user tries to call a OnlyGovernor function\n    error OnlyGovernor();\n\n    /// @notice Thrown if a non-pending-governor user tries to call a OnlyPendingGovernor function\n    error OnlyPendingGovernor();\n\n    // FUNCTIONS\n\n    /// @notice Allows a governor to propose a new governor\n    /// @param _pendingGovernor Address of the proposed new governor\n    function setPendingGovernor(address _pendingGovernor) external;\n\n    /// @notice Allows a proposed governor to accept the governance\n    function acceptPendingGovernor() external;\n}\n"
    },
    "solidity/for-test/JobForTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport \"../interfaces/IKeep3r.sol\";\n\ncontract BasicJob {\n    error KeeperNotValid();\n\n    address public keep3r;\n    uint256 public nonce;\n    uint256[] public array;\n\n    constructor(address _keep3r) {\n        keep3r = _keep3r;\n    }\n\n    function test() external {\n        array.push(1);\n    }\n}\n"
    },
    "solidity/interfaces/IKeep3r.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport './peripherals/IKeep3rJobs.sol';\nimport './peripherals/IKeep3rKeepers.sol';\nimport './peripherals/IKeep3rParameters.sol';\n\n// solhint-disable-next-line no-empty-blocks\n\n/// @title Keep3rV2 contract\n/// @notice This contract inherits all the functionality of Keep3rV2\ninterface IKeep3r is IKeep3rJobs, IKeep3rKeepers, IKeep3rParameters {\n\n}\n"
    },
    "solidity/interfaces/peripherals/IKeep3rAccountance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport './IKeep3rRoles.sol';\n\n/// @title Keep3rDisputable contract\n/// @notice Disputes keepers, or if they're already disputed, it can resolve the case\n/// @dev Argument `bonding` can be the address of either a token or a liquidity\ninterface IKeep3rAccountance is IKeep3rRoles {\n  // Events\n\n  /// @notice Emitted when the bonding process of a new keeper begins\n  /// @param _keeper The caller of Keep3rKeeperFundable#bond function\n  /// @param _bonding The asset the keeper has bonded\n  /// @param _amount The amount the keeper has bonded\n  event Bonding(address indexed _keeper, address indexed _bonding, uint256 _amount);\n\n  /// @notice Emitted when a keeper or job begins the unbonding process to withdraw the funds\n  /// @param _keeperOrJob The keeper or job that began the unbonding process\n  /// @param _unbonding The liquidity pair or asset being unbonded\n  /// @param _amount The amount being unbonded\n  event Unbonding(address indexed _keeperOrJob, address indexed _unbonding, uint256 _amount);\n\n  // Variables\n\n  /// @notice Tracks the total amount of bonded KP3Rs in the contract\n  /// @return _totalBonds The total amount of bonded KP3Rs in the contract\n  function totalBonds() external view returns (uint256 _totalBonds);\n\n  /// @notice Tracks the total KP3R earnings of a keeper since it started working\n  /// @param _keeper The address of the keeper\n  /// @return _workCompleted Total KP3R earnings of a keeper since it started working\n  function workCompleted(address _keeper) external view returns (uint256 _workCompleted);\n\n  /// @notice Tracks when a keeper was first registered\n  /// @param _keeper The address of the keeper\n  /// @return timestamp The time at which the keeper was first registered\n  function firstSeen(address _keeper) external view returns (uint256 timestamp);\n\n  /// @notice Tracks if a keeper or job has a pending dispute\n  /// @param _keeperOrJob The address of the keeper or job\n  /// @return _disputed Whether a keeper or job has a pending dispute\n  function disputes(address _keeperOrJob) external view returns (bool _disputed);\n\n  /// @notice Tracks how much a keeper has bonded of a certain token\n  /// @param _keeper The address of the keeper\n  /// @param _bond The address of the token being bonded\n  /// @return _bonds Amount of a certain token that a keeper has bonded\n  function bonds(address _keeper, address _bond) external view returns (uint256 _bonds);\n\n  /// @notice The current token credits available for a job\n  /// @param _job The address of the job\n  /// @param _token The address of the token bonded\n  /// @return _amount The amount of token credits available for a job\n  function jobTokenCredits(address _job, address _token) external view returns (uint256 _amount);\n\n  /// @notice Tracks the amount of assets deposited in pending bonds\n  /// @param _keeper The address of the keeper\n  /// @param _bonding The address of the token being bonded\n  /// @return _pendingBonds Amount of a certain asset a keeper has unbonding\n  function pendingBonds(address _keeper, address _bonding) external view returns (uint256 _pendingBonds);\n\n  /// @notice Tracks when a bonding for a keeper can be activated\n  /// @param _keeper The address of the keeper\n  /// @param _bonding The address of the token being bonded\n  /// @return _timestamp Time at which the bonding for a keeper can be activated\n  function canActivateAfter(address _keeper, address _bonding) external view returns (uint256 _timestamp);\n\n  /// @notice Tracks when keeper bonds are ready to be withdrawn\n  /// @param _keeper The address of the keeper\n  /// @param _bonding The address of the token being unbonded\n  /// @return _timestamp Time at which the keeper bonds are ready to be withdrawn\n  function canWithdrawAfter(address _keeper, address _bonding) external view returns (uint256 _timestamp);\n\n  /// @notice Tracks how much keeper bonds are to be withdrawn\n  /// @param _keeper The address of the keeper\n  /// @param _bonding The address of the token being unbonded\n  /// @return _pendingUnbonds The amount of keeper bonds that are to be withdrawn\n  function pendingUnbonds(address _keeper, address _bonding) external view returns (uint256 _pendingUnbonds);\n\n  /// @notice Checks whether the address has ever bonded an asset\n  /// @param _keeper The address of the keeper\n  /// @return _hasBonded Whether the address has ever bonded an asset\n  function hasBonded(address _keeper) external view returns (bool _hasBonded);\n\n  // Methods\n\n  /// @notice Lists all jobs\n  /// @return _jobList Array with all the jobs in _jobs\n  function jobs() external view returns (address[] memory _jobList);\n\n  /// @notice Lists all keepers\n  /// @return _keeperList Array with all the keepers in _keepers\n  function keepers() external view returns (address[] memory _keeperList);\n\n  // Errors\n\n  /// @notice Throws when an address is passed as a job, but that address is not a job\n  error JobUnavailable();\n\n  /// @notice Throws when an action that requires an undisputed job is applied on a disputed job\n  error JobDisputed();\n}\n"
    },
    "solidity/interfaces/peripherals/IKeep3rDisputable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\n/// @title Keep3rDisputable contract\n/// @notice Creates/resolves disputes for jobs or keepers\n///         A disputed keeper is slashable and is not able to bond, activate, withdraw or receive direct payments\n///         A disputed job is slashable and is not able to pay the keepers, withdraw tokens or to migrate\ninterface IKeep3rDisputable {\n  /// @notice Emitted when a keeper or a job is disputed\n  /// @param _jobOrKeeper The address of the disputed keeper/job\n  /// @param _disputer The user that called the function and disputed the keeper\n  event Dispute(address indexed _jobOrKeeper, address indexed _disputer);\n\n  /// @notice Emitted when a dispute is resolved\n  /// @param _jobOrKeeper The address of the disputed keeper/job\n  /// @param _resolver The user that called the function and resolved the dispute\n  event Resolve(address indexed _jobOrKeeper, address indexed _resolver);\n\n  /// @notice Throws when a job or keeper is already disputed\n  error AlreadyDisputed();\n\n  /// @notice Throws when a job or keeper is not disputed and someone tries to resolve the dispute\n  error NotDisputed();\n\n  /// @notice Allows governor to create a dispute for a given keeper/job\n  /// @param _jobOrKeeper The address in dispute\n  function dispute(address _jobOrKeeper) external;\n\n  /// @notice Allows governor to resolve a dispute on a keeper/job\n  /// @param _jobOrKeeper The address cleared\n  function resolve(address _jobOrKeeper) external;\n}\n"
    },
    "solidity/interfaces/peripherals/IKeep3rJobs.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport './IKeep3rDisputable.sol';\n\n/// @title Keep3rJobOwnership contract\n/// @notice Handles the ownership of the jobs\ninterface IKeep3rJobOwnership {\n  // Events\n\n  /// @notice Emitted when Keep3rJobOwnership#changeJobOwnership is called\n  /// @param _job The address of the job proposed to have a change of owner\n  /// @param _owner The current owner of the job\n  /// @param _pendingOwner The new address proposed to be the owner of the job\n  event JobOwnershipChange(address indexed _job, address indexed _owner, address indexed _pendingOwner);\n\n  /// @notice Emitted when Keep3rJobOwnership#JobOwnershipAssent is called\n  /// @param _job The address of the job which the proposed owner will now own\n  /// @param _previousOwner The previous owner of the job\n  /// @param _newOwner The new owner of the job\n  event JobOwnershipAssent(address indexed _job, address indexed _previousOwner, address indexed _newOwner);\n\n  // Errors\n\n  /// @notice Throws when the caller of the function is not the job owner\n  error OnlyJobOwner();\n\n  /// @notice Throws when the caller of the function is not the pending job owner\n  error OnlyPendingJobOwner();\n\n  // Variables\n\n  /// @notice Maps the job to the owner of the job\n  /// @param _job The address of the job\n  /// @return _owner The address of the owner of the job\n  function jobOwner(address _job) external view returns (address _owner);\n\n  /// @notice Maps the job to its pending owner\n  /// @param _job The address of the job\n  /// @return _pendingOwner The address of the pending owner of the job\n  function jobPendingOwner(address _job) external view returns (address _pendingOwner);\n\n  // Methods\n\n  /// @notice Proposes a new address to be the owner of the job\n  /// @param _job The address of the job\n  /// @param _newOwner The address of the proposed new owner\n  function changeJobOwnership(address _job, address _newOwner) external;\n\n  /// @notice The proposed address accepts to be the owner of the job\n  /// @param _job The address of the job\n  function acceptJobOwnership(address _job) external;\n}\n\n/// @title Keep3rJobManager contract\n/// @notice Handles the addition and withdrawal of credits from a job\ninterface IKeep3rJobManager is IKeep3rJobOwnership {\n  // Events\n\n  /// @notice Emitted when Keep3rJobManager#addJob is called\n  /// @param _job The address of the job to add\n  /// @param _jobOwner The job's owner\n  event JobAddition(address indexed _job, address indexed _jobOwner);\n\n  // Errors\n\n  /// @notice Throws when trying to add a job that has already been added\n  error JobAlreadyAdded();\n\n  /// @notice Throws when the address that is trying to register as a keeper is already a keeper\n  error AlreadyAKeeper();\n\n  // Methods\n\n  /// @notice Allows any caller to add a new job\n  /// @param _job Address of the contract for which work should be performed\n  function addJob(address _job) external;\n}\n\n/// @title Keep3rJobFundableCredits contract\n/// @notice Handles the addition and withdrawal of credits from a job\ninterface IKeep3rJobFundableCredits is IKeep3rJobOwnership {\n  // Events\n\n  /// @notice Emitted when Keep3rJobFundableCredits#addTokenCreditsToJob is called\n  /// @param _job The address of the job being credited\n  /// @param _token The address of the token being provided\n  /// @param _provider The user that calls the function\n  /// @param _amount The amount of credit being added to the job\n  event TokenCreditAddition(address indexed _job, address indexed _token, address indexed _provider, uint256 _amount);\n\n  /// @notice Emitted when Keep3rJobFundableCredits#withdrawTokenCreditsFromJob is called\n  /// @param _job The address of the job from which the credits are withdrawn\n  /// @param _token The credit being withdrawn from the job\n  /// @param _receiver The user that receives the tokens\n  /// @param _amount The amount of credit withdrawn\n  event TokenCreditWithdrawal(address indexed _job, address indexed _token, address indexed _receiver, uint256 _amount);\n\n  // Errors\n\n  /// @notice Throws when the token is KP3R, as it should not be used for direct token payments\n  error TokenUnallowed();\n\n  /// @notice Throws when the token withdraw cooldown has not yet passed\n  error JobTokenCreditsLocked();\n\n  /// @notice Throws when the user tries to withdraw more tokens than it has\n  error InsufficientJobTokenCredits();\n\n  // Variables\n\n  /// @notice Last block where tokens were added to the job\n  /// @param _job The address of the job credited\n  /// @param _token The address of the token credited\n  /// @return _timestamp The last block where tokens were added to the job\n  function jobTokenCreditsAddedAt(address _job, address _token) external view returns (uint256 _timestamp);\n\n  // Methods\n\n  /// @notice Add credit to a job to be paid out for work\n  /// @param _job The address of the job being credited\n  /// @param _token The address of the token being credited\n  /// @param _amount The amount of credit being added\n  function addTokenCreditsToJob(\n    address _job,\n    address _token,\n    uint256 _amount\n  ) external;\n\n  /// @notice Withdraw credit from a job\n  /// @param _job The address of the job from which the credits are withdrawn\n  /// @param _token The address of the token being withdrawn\n  /// @param _amount The amount of token to be withdrawn\n  /// @param _receiver The user that will receive tokens\n  function withdrawTokenCreditsFromJob(\n    address _job,\n    address _token,\n    uint256 _amount,\n    address _receiver\n  ) external;\n}\n\n/// @title  Keep3rJobFundableLiquidity contract\n/// @notice Handles the funding of jobs through specific liquidity pairs\ninterface IKeep3rJobFundableLiquidity is IKeep3rJobOwnership {\n  // Events\n\n  /// @notice Emitted when Keep3rJobFundableLiquidity#approveLiquidity function is called\n  /// @param _liquidity The address of the liquidity pair being approved\n  event LiquidityApproval(address _liquidity);\n\n  /// @notice Emitted when Keep3rJobFundableLiquidity#revokeLiquidity function is called\n  /// @param _liquidity The address of the liquidity pair being revoked\n  event LiquidityRevocation(address _liquidity);\n\n  /// @notice Emitted when IKeep3rJobFundableLiquidity#addLiquidityToJob function is called\n  /// @param _job The address of the job to which liquidity will be added\n  /// @param _liquidity The address of the liquidity being added\n  /// @param _provider The user that calls the function\n  /// @param _amount The amount of liquidity being added\n  event LiquidityAddition(address indexed _job, address indexed _liquidity, address indexed _provider, uint256 _amount);\n\n  /// @notice Emitted when IKeep3rJobFundableLiquidity#withdrawLiquidityFromJob function is called\n  /// @param _job The address of the job of which liquidity will be withdrawn from\n  /// @param _liquidity The address of the liquidity being withdrawn\n  /// @param _receiver The receiver of the liquidity tokens\n  /// @param _amount The amount of liquidity being withdrawn from the job\n  event LiquidityWithdrawal(address indexed _job, address indexed _liquidity, address indexed _receiver, uint256 _amount);\n\n  /// @notice Emitted when Keep3rJobFundableLiquidity#addLiquidityToJob function is called\n  /// @param _job The address of the job whose credits will be updated\n  /// @param _rewardedAt The time at which the job was last rewarded\n  /// @param _currentCredits The current credits of the job\n  /// @param _periodCredits The credits of the job for the current period\n  event LiquidityCreditsReward(address indexed _job, uint256 _rewardedAt, uint256 _currentCredits, uint256 _periodCredits);\n\n  /// @notice Emitted when Keep3rJobFundableLiquidity#forceLiquidityCreditsToJob function is called\n  /// @param _job The address of the job whose credits will be updated\n  /// @param _rewardedAt The time at which the job was last rewarded\n  /// @param _currentCredits The current credits of the job\n  event LiquidityCreditsForced(address indexed _job, uint256 _rewardedAt, uint256 _currentCredits);\n\n  // Errors\n\n  /// @notice Throws when the liquidity being approved has already been approved\n  error LiquidityPairApproved();\n\n  /// @notice Throws when the liquidity being removed has not been approved\n  error LiquidityPairUnexistent();\n\n  /// @notice Throws when trying to add liquidity to an unapproved pool\n  error LiquidityPairUnapproved();\n\n  /// @notice Throws when the job doesn't have the requested liquidity\n  error JobLiquidityUnexistent();\n\n  /// @notice Throws when trying to remove more liquidity than the job has\n  error JobLiquidityInsufficient();\n\n  /// @notice Throws when trying to add less liquidity than the minimum liquidity required\n  error JobLiquidityLessThanMin();\n\n  // Structs\n\n  /// @notice Stores the tick information of the different liquidity pairs\n  struct TickCache {\n    int56 current; // Tracks the current tick\n    int56 difference; // Stores the difference between the current tick and the last tick\n    uint256 period; // Stores the period at which the last observation was made\n  }\n\n  // Variables\n\n  /// @notice Lists liquidity pairs\n  /// @return _list An array of addresses with all the approved liquidity pairs\n  function approvedLiquidities() external view returns (address[] memory _list);\n\n  /// @notice Amount of liquidity in a specified job\n  /// @param _job The address of the job being checked\n  /// @param _liquidity The address of the liquidity we are checking\n  /// @return _amount Amount of liquidity in the specified job\n  function liquidityAmount(address _job, address _liquidity) external view returns (uint256 _amount);\n\n  /// @notice Last time the job was rewarded liquidity credits\n  /// @param _job The address of the job being checked\n  /// @return _timestamp Timestamp of the last time the job was rewarded liquidity credits\n  function rewardedAt(address _job) external view returns (uint256 _timestamp);\n\n  /// @notice Last time the job was worked\n  /// @param _job The address of the job being checked\n  /// @return _timestamp Timestamp of the last time the job was worked\n  function workedAt(address _job) external view returns (uint256 _timestamp);\n\n  // Methods\n\n  /// @notice Returns the liquidity credits of a given job\n  /// @param _job The address of the job of which we want to know the liquidity credits\n  /// @return _amount The liquidity credits of a given job\n  function jobLiquidityCredits(address _job) external view returns (uint256 _amount);\n\n  /// @notice Returns the credits of a given job for the current period\n  /// @param _job The address of the job of which we want to know the period credits\n  /// @return _amount The credits the given job has at the current period\n  function jobPeriodCredits(address _job) external view returns (uint256 _amount);\n\n  /// @notice Calculates the total credits of a given job\n  /// @param _job The address of the job of which we want to know the total credits\n  /// @return _amount The total credits of the given job\n  function totalJobCredits(address _job) external view returns (uint256 _amount);\n\n  /// @notice Calculates how many credits should be rewarded periodically for a given liquidity amount\n  /// @dev _periodCredits = underlying KP3Rs for given liquidity amount * rewardPeriod / inflationPeriod\n  /// @param _liquidity The address of the liquidity to provide\n  /// @param _amount The amount of liquidity to provide\n  /// @return _periodCredits The amount of KP3R periodically minted for the given liquidity\n  function quoteLiquidity(address _liquidity, uint256 _amount) external view returns (uint256 _periodCredits);\n\n  /// @notice Observes the current state of the liquidity pair being observed and updates TickCache with the information\n  /// @param _liquidity The address of the liquidity pair being observed\n  /// @return _tickCache The updated TickCache\n  function observeLiquidity(address _liquidity) external view returns (TickCache memory _tickCache);\n\n  /// @notice Gifts liquidity credits to the specified job\n  /// @param _job The address of the job being credited\n  /// @param _amount The amount of liquidity credits to gift\n  function forceLiquidityCreditsToJob(address _job, uint256 _amount) external;\n\n  /// @notice Approve a liquidity pair for being accepted in future\n  /// @param _liquidity The address of the liquidity accepted\n  function approveLiquidity(address _liquidity) external;\n\n  /// @notice Revoke a liquidity pair from being accepted in future\n  /// @param _liquidity The liquidity no longer accepted\n  function revokeLiquidity(address _liquidity) external;\n\n  /// @notice Allows anyone to fund a job with liquidity\n  /// @param _job The address of the job to assign liquidity to\n  /// @param _liquidity The liquidity being added\n  /// @param _amount The amount of liquidity tokens to add\n  function addLiquidityToJob(\n    address _job,\n    address _liquidity,\n    uint256 _amount\n  ) external;\n\n  /// @notice Unbond liquidity for a job\n  /// @dev Can only be called by the job's owner\n  /// @param _job The address of the job being unbonded from\n  /// @param _liquidity The liquidity being unbonded\n  /// @param _amount The amount of liquidity being removed\n  function unbondLiquidityFromJob(\n    address _job,\n    address _liquidity,\n    uint256 _amount\n  ) external;\n\n  /// @notice Withdraw liquidity from a job\n  /// @param _job The address of the job being withdrawn from\n  /// @param _liquidity The liquidity being withdrawn\n  /// @param _receiver The address that will receive the withdrawn liquidity\n  function withdrawLiquidityFromJob(\n    address _job,\n    address _liquidity,\n    address _receiver\n  ) external;\n}\n\n/// @title Keep3rJobMigration contract\n/// @notice Handles the migration process of jobs to different addresses\ninterface IKeep3rJobMigration is IKeep3rJobFundableCredits, IKeep3rJobFundableLiquidity {\n  // Events\n\n  /// @notice Emitted when Keep3rJobMigration#migrateJob function is called\n  /// @param _fromJob The address of the job that requests to migrate\n  /// @param _toJob The address at which the job requests to migrate\n  event JobMigrationRequested(address indexed _fromJob, address _toJob);\n\n  /// @notice Emitted when Keep3rJobMigration#acceptJobMigration function is called\n  /// @param _fromJob The address of the job that requested to migrate\n  /// @param _toJob The address at which the job had requested to migrate\n  event JobMigrationSuccessful(address _fromJob, address indexed _toJob);\n\n  // Errors\n\n  /// @notice Throws when the address of the job that requests to migrate wants to migrate to its same address\n  error JobMigrationImpossible();\n\n  /// @notice Throws when the _toJob address differs from the address being tracked in the pendingJobMigrations mapping\n  error JobMigrationUnavailable();\n\n  /// @notice Throws when cooldown between migrations has not yet passed\n  error JobMigrationLocked();\n\n  // Variables\n\n  /// @notice Maps the jobs that have requested a migration to the address they have requested to migrate to\n  /// @return _toJob The address to which the job has requested to migrate to\n  function pendingJobMigrations(address _fromJob) external view returns (address _toJob);\n\n  // Methods\n\n  /// @notice Initializes the migration process for a job by adding the request to the pendingJobMigrations mapping\n  /// @param _fromJob The address of the job that is requesting to migrate\n  /// @param _toJob The address at which the job is requesting to migrate\n  function migrateJob(address _fromJob, address _toJob) external;\n\n  /// @notice Completes the migration process for a job\n  /// @dev Unbond/withdraw process doesn't get migrated\n  /// @param _fromJob The address of the job that requested to migrate\n  /// @param _toJob The address to which the job wants to migrate to\n  function acceptJobMigration(address _fromJob, address _toJob) external;\n}\n\n/// @title Keep3rJobWorkable contract\n/// @notice Handles the mechanisms jobs can pay keepers with along with the restrictions jobs can put on keepers before they can work on jobs\ninterface IKeep3rJobWorkable is IKeep3rJobMigration {\n  // Events\n\n  /// @notice Emitted when a keeper is validated before a job\n  /// @param _gasLeft The amount of gas that the transaction has left at the moment of keeper validation\n  event KeeperValidation(uint256 _gasLeft);\n\n  /// @notice Emitted when a keeper works a job\n  /// @param _credit The address of the asset in which the keeper is paid\n  /// @param _job The address of the job the keeper has worked\n  /// @param _keeper The address of the keeper that has worked the job\n  /// @param _payment The amount that has been paid out to the keeper in exchange for working the job\n  /// @param _gasLeft The amount of gas that the transaction has left at the moment of payment\n  event KeeperWork(address indexed _credit, address indexed _job, address indexed _keeper, uint256 _payment, uint256 _gasLeft);\n\n  // Errors\n\n  /// @notice Throws if work method was called without calling isKeeper or isBondedKeeper\n  error GasNotInitialized();\n\n  /// @notice Throws if the address claiming to be a job is not in the list of approved jobs\n  error JobUnapproved();\n\n  /// @notice Throws if the amount of funds in the job is less than the payment that must be paid to the keeper that works that job\n  error InsufficientFunds();\n\n  // Methods\n\n  /// @notice Confirms if the current keeper is registered\n  /// @dev Can be used for general (non critical) functions\n  /// @param _keeper The keeper being investigated\n  /// @return _isKeeper Whether the address passed as a parameter is a keeper or not\n  function isKeeper(address _keeper) external returns (bool _isKeeper);\n\n  /// @notice Confirms if the current keeper is registered and has a minimum bond of any asset.\n  /// @dev Should be used for protected functions\n  /// @param _keeper The keeper to check\n  /// @param _bond The bond token being evaluated\n  /// @param _minBond The minimum amount of bonded tokens\n  /// @param _earned The minimum funds earned in the keepers lifetime\n  /// @param _age The minimum keeper age required\n  /// @return _isBondedKeeper Whether the `_keeper` meets the given requirements\n  function isBondedKeeper(\n    address _keeper,\n    address _bond,\n    uint256 _minBond,\n    uint256 _earned,\n    uint256 _age\n  ) external returns (bool _isBondedKeeper);\n\n  /// @notice Implemented by jobs to show that a keeper performed work\n  /// @dev Automatically calculates the payment for the keeper and pays the keeper with bonded KP3R\n  /// @param _keeper Address of the keeper that performed the work\n  function worked(address _keeper) external;\n\n  /// @notice Implemented by jobs to show that a keeper performed work\n  /// @dev Pays the keeper that performs the work with KP3R\n  /// @param _keeper Address of the keeper that performed the work\n  /// @param _payment The reward that should be allocated for the job\n  function bondedPayment(address _keeper, uint256 _payment) external;\n\n  /// @notice Implemented by jobs to show that a keeper performed work\n  /// @dev Pays the keeper that performs the work with a specific token\n  /// @param _token The asset being awarded to the keeper\n  /// @param _keeper Address of the keeper that performed the work\n  /// @param _amount The reward that should be allocated\n  function directTokenPayment(\n    address _token,\n    address _keeper,\n    uint256 _amount\n  ) external;\n}\n\n/// @title Keep3rJobDisputable contract\n/// @notice Handles the actions that can be taken on a disputed job\ninterface IKeep3rJobDisputable is IKeep3rDisputable, IKeep3rJobFundableCredits, IKeep3rJobFundableLiquidity {\n  // Events\n\n  /// @notice Emitted when Keep3rJobDisputable#slashTokenFromJob is called\n  /// @param _job The address of the job from which the token will be slashed\n  /// @param _token The address of the token being slashed\n  /// @param _slasher The user that slashes the token\n  /// @param _amount The amount of the token being slashed\n  event JobSlashToken(address indexed _job, address _token, address indexed _slasher, uint256 _amount);\n\n  /// @notice Emitted when Keep3rJobDisputable#slashLiquidityFromJob is called\n  /// @param _job The address of the job from which the liquidity will be slashed\n  /// @param _liquidity The address of the liquidity being slashed\n  /// @param _slasher The user that slashes the liquidity\n  /// @param _amount The amount of the liquidity being slashed\n  event JobSlashLiquidity(address indexed _job, address _liquidity, address indexed _slasher, uint256 _amount);\n\n  // Errors\n\n  /// @notice Throws when the token trying to be slashed doesn't exist\n  error JobTokenUnexistent();\n\n  /// @notice Throws when someone tries to slash more tokens than the job has\n  error JobTokenInsufficient();\n\n  // Methods\n\n  /// @notice Allows governor or slasher to slash a job specific token\n  /// @param _job The address of the job from which the token will be slashed\n  /// @param _token The address of the token that will be slashed\n  /// @param _amount The amount of the token that will be slashed\n  function slashTokenFromJob(\n    address _job,\n    address _token,\n    uint256 _amount\n  ) external;\n\n  /// @notice Allows governor or slasher to slash liquidity from a job\n  /// @param _job The address being slashed\n  /// @param _liquidity The address of the liquidity that will be slashed\n  /// @param _amount The amount of liquidity that will be slashed\n  function slashLiquidityFromJob(\n    address _job,\n    address _liquidity,\n    uint256 _amount\n  ) external;\n}\n\n// solhint-disable-next-line no-empty-blocks\ninterface IKeep3rJobs is IKeep3rJobWorkable, IKeep3rJobManager, IKeep3rJobDisputable {\n\n}\n"
    },
    "solidity/interfaces/peripherals/IKeep3rKeepers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport './IKeep3rDisputable.sol';\n\n/// @title Keep3rKeeperFundable contract\n/// @notice Handles the actions required to become a keeper\ninterface IKeep3rKeeperFundable {\n  // Events\n\n  /// @notice Emitted when Keep3rKeeperFundable#activate is called\n  /// @param _keeper The keeper that has been activated\n  /// @param _bond The asset the keeper has bonded\n  /// @param _amount The amount of the asset the keeper has bonded\n  event Activation(address indexed _keeper, address indexed _bond, uint256 _amount);\n\n  /// @notice Emitted when Keep3rKeeperFundable#withdraw is called\n  /// @param _keeper The caller of Keep3rKeeperFundable#withdraw function\n  /// @param _bond The asset to withdraw from the bonding pool\n  /// @param _amount The amount of funds withdrawn\n  event Withdrawal(address indexed _keeper, address indexed _bond, uint256 _amount);\n\n  // Errors\n\n  /// @notice Throws when the address that is trying to register as a job is already a job\n  error AlreadyAJob();\n\n  // Methods\n\n  /// @notice Beginning of the bonding process\n  /// @param _bonding The asset being bonded\n  /// @param _amount The amount of bonding asset being bonded\n  function bond(address _bonding, uint256 _amount) external;\n\n  /// @notice Beginning of the unbonding process\n  /// @param _bonding The asset being unbonded\n  /// @param _amount Allows for partial unbonding\n  function unbond(address _bonding, uint256 _amount) external;\n\n  /// @notice End of the bonding process after bonding time has passed\n  /// @param _bonding The asset being activated as bond collateral\n  function activate(address _bonding) external;\n\n  /// @notice Withdraw funds after unbonding has finished\n  /// @param _bonding The asset to withdraw from the bonding pool\n  function withdraw(address _bonding) external;\n}\n\n/// @title Keep3rKeeperDisputable contract\n/// @notice Handles the actions that can be taken on a disputed keeper\ninterface IKeep3rKeeperDisputable is IKeep3rDisputable, IKeep3rKeeperFundable {\n  // Events\n\n  /// @notice Emitted when Keep3rKeeperDisputable#slash is called\n  /// @param _keeper The address of the slashed keeper\n  /// @param _slasher The user that called Keep3rKeeperDisputable#slash\n  /// @param _amount The amount of credits slashed from the keeper\n  event KeeperSlash(address indexed _keeper, address indexed _slasher, uint256 _amount);\n\n  /// @notice Emitted when Keep3rKeeperDisputable#revoke is called\n  /// @param _keeper The address of the revoked keeper\n  /// @param _slasher The user that called Keep3rKeeperDisputable#revoke\n  event KeeperRevoke(address indexed _keeper, address indexed _slasher);\n\n  // Methods\n\n  /// @notice Allows governor to slash a keeper based on a dispute\n  /// @param _keeper The address being slashed\n  /// @param _bonded The asset being slashed\n  /// @param _bondAmount The bonded amount being slashed\n  /// @param _unbondAmount The pending unbond amount being slashed\n  function slash(\n    address _keeper,\n    address _bonded,\n    uint256 _bondAmount,\n    uint256 _unbondAmount\n  ) external;\n\n  /// @notice Blacklists a keeper from participating in the network\n  /// @param _keeper The address being slashed\n  function revoke(address _keeper) external;\n}\n\n// solhint-disable-next-line no-empty-blocks\n\n/// @title Keep3rKeepers contract\ninterface IKeep3rKeepers is IKeep3rKeeperDisputable {\n\n}\n"
    },
    "solidity/interfaces/peripherals/IKeep3rParameters.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport './IKeep3rAccountance.sol';\n\n/// @title Keep3rParameters contract\n/// @notice Handles and sets all the required parameters for Keep3r\ninterface IKeep3rParameters is IKeep3rAccountance {\n  // Events\n\n  /// @notice Emitted when the Keep3rHelper address is changed\n  /// @param _keep3rHelper The address of Keep3rHelper's contract\n  event Keep3rHelperChange(address _keep3rHelper);\n\n  /// @notice Emitted when the Keep3rV1 address is changed\n  /// @param _keep3rV1 The address of Keep3rV1's contract\n  event Keep3rV1Change(address _keep3rV1);\n\n  /// @notice Emitted when the Keep3rV1Proxy address is changed\n  /// @param _keep3rV1Proxy The address of Keep3rV1Proxy's contract\n  event Keep3rV1ProxyChange(address _keep3rV1Proxy);\n\n  /// @notice Emitted when bondTime is changed\n  /// @param _bondTime The new bondTime\n  event BondTimeChange(uint256 _bondTime);\n\n  /// @notice Emitted when _liquidityMinimum is changed\n  /// @param _liquidityMinimum The new _liquidityMinimum\n  event LiquidityMinimumChange(uint256 _liquidityMinimum);\n\n  /// @notice Emitted when _unbondTime is changed\n  /// @param _unbondTime The new _unbondTime\n  event UnbondTimeChange(uint256 _unbondTime);\n\n  /// @notice Emitted when _rewardPeriodTime is changed\n  /// @param _rewardPeriodTime The new _rewardPeriodTime\n  event RewardPeriodTimeChange(uint256 _rewardPeriodTime);\n\n  /// @notice Emitted when the inflationPeriod is changed\n  /// @param _inflationPeriod The new inflationPeriod\n  event InflationPeriodChange(uint256 _inflationPeriod);\n\n  /// @notice Emitted when the fee is changed\n  /// @param _fee The new token credits fee\n  event FeeChange(uint256 _fee);\n\n  // Variables\n\n  /// @notice Address of Keep3rHelper's contract\n  /// @return _keep3rHelper The address of Keep3rHelper's contract\n  function keep3rHelper() external view returns (address _keep3rHelper);\n\n  /// @notice Address of Keep3rV1's contract\n  /// @return _keep3rV1 The address of Keep3rV1's contract\n  function keep3rV1() external view returns (address _keep3rV1);\n\n  /// @notice Address of Keep3rV1Proxy's contract\n  /// @return _keep3rV1Proxy The address of Keep3rV1Proxy's contract\n  function keep3rV1Proxy() external view returns (address _keep3rV1Proxy);\n\n  /// @notice The amount of time required to pass after a keeper has bonded assets for it to be able to activate\n  /// @return _days The required bondTime in days\n  function bondTime() external view returns (uint256 _days);\n\n  /// @notice The amount of time required to pass before a keeper can unbond what he has bonded\n  /// @return _days The required unbondTime in days\n  function unbondTime() external view returns (uint256 _days);\n\n  /// @notice The minimum amount of liquidity required to fund a job per liquidity\n  /// @return _amount The minimum amount of liquidity in KP3R\n  function liquidityMinimum() external view returns (uint256 _amount);\n\n  /// @notice The amount of time between each scheduled credits reward given to a job\n  /// @return _days The reward period in days\n  function rewardPeriodTime() external view returns (uint256 _days);\n\n  /// @notice The inflation period is the denominator used to regulate the emission of KP3R\n  /// @return _period The denominator used to regulate the emission of KP3R\n  function inflationPeriod() external view returns (uint256 _period);\n\n  /// @notice The fee to be sent to governor when a user adds liquidity to a job\n  /// @return _amount The fee amount to be sent to governor when a user adds liquidity to a job\n  function fee() external view returns (uint256 _amount);\n\n  // Errors\n\n  /// @notice Throws if the reward period is less than the minimum reward period time\n  error MinRewardPeriod();\n\n  /// @notice Throws if either a job or a keeper is disputed\n  error Disputed();\n\n  /// @notice Throws if there are no bonded assets\n  error BondsUnexistent();\n\n  /// @notice Throws if the time required to bond an asset has not passed yet\n  error BondsLocked();\n\n  /// @notice Throws if there are no bonds to withdraw\n  error UnbondsUnexistent();\n\n  /// @notice Throws if the time required to withdraw the bonds has not passed yet\n  error UnbondsLocked();\n\n  // Methods\n\n  /// @notice Sets the Keep3rHelper address\n  /// @param _keep3rHelper The Keep3rHelper address\n  function setKeep3rHelper(address _keep3rHelper) external;\n\n  /// @notice Sets the Keep3rV1 address\n  /// @param _keep3rV1 The Keep3rV1 address\n  function setKeep3rV1(address _keep3rV1) external;\n\n  /// @notice Sets the Keep3rV1Proxy address\n  /// @param _keep3rV1Proxy The Keep3rV1Proxy address\n  function setKeep3rV1Proxy(address _keep3rV1Proxy) external;\n\n  /// @notice Sets the bond time required to activate as a keeper\n  /// @param _bond The new bond time\n  function setBondTime(uint256 _bond) external;\n\n  /// @notice Sets the unbond time required unbond what has been bonded\n  /// @param _unbond The new unbond time\n  function setUnbondTime(uint256 _unbond) external;\n\n  /// @notice Sets the minimum amount of liquidity required to fund a job\n  /// @param _liquidityMinimum The new minimum amount of liquidity\n  function setLiquidityMinimum(uint256 _liquidityMinimum) external;\n\n  /// @notice Sets the time required to pass between rewards for jobs\n  /// @param _rewardPeriodTime The new amount of time required to pass between rewards\n  function setRewardPeriodTime(uint256 _rewardPeriodTime) external;\n\n  /// @notice Sets the new inflation period\n  /// @param _inflationPeriod The new inflation period\n  function setInflationPeriod(uint256 _inflationPeriod) external;\n\n  /// @notice Sets the new fee\n  /// @param _fee The new fee\n  function setFee(uint256 _fee) external;\n}\n"
    },
    "solidity/interfaces/peripherals/IKeep3rRoles.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport '@defi-wonderland/solidity-utils/solidity/interfaces/IBaseErrors.sol';\nimport '@defi-wonderland/solidity-utils/solidity/interfaces/IGovernable.sol';\nimport '@defi-wonderland/solidity-utils/solidity/interfaces/IDustCollector.sol';\n\n/// @title Keep3rRoles contract\n/// @notice Manages the Keep3r specific roles\ninterface IKeep3rRoles is IBaseErrors, IGovernable, IDustCollector {\n  // Events\n\n  /// @notice Emitted when a slasher is added\n  /// @param _slasher Address of the added slasher\n  event SlasherAdded(address _slasher);\n\n  /// @notice Emitted when a slasher is removed\n  /// @param _slasher Address of the removed slasher\n  event SlasherRemoved(address _slasher);\n\n  /// @notice Emitted when a disputer is added\n  /// @param _disputer Address of the added disputer\n  event DisputerAdded(address _disputer);\n\n  /// @notice Emitted when a disputer is removed\n  /// @param _disputer Address of the removed disputer\n  event DisputerRemoved(address _disputer);\n\n  // Variables\n\n  /// @notice Tracks whether the address is a slasher or not\n  /// @param _slasher Address being checked as a slasher\n  /// @return _isSlasher Whether the address is a slasher or not\n  function slashers(address _slasher) external view returns (bool _isSlasher);\n\n  /// @notice Tracks whether the address is a disputer or not\n  /// @param _disputer Address being checked as a disputer\n  /// @return _isDisputer Whether the address is a disputer or not\n  function disputers(address _disputer) external view returns (bool _isDisputer);\n\n  // Errors\n\n  /// @notice Throws if the address is already a registered slasher\n  error SlasherExistent();\n\n  /// @notice Throws if caller is not a registered slasher\n  error SlasherUnexistent();\n\n  /// @notice Throws if the address is already a registered disputer\n  error DisputerExistent();\n\n  /// @notice Throws if caller is not a registered disputer\n  error DisputerUnexistent();\n\n  /// @notice Throws if the msg.sender is not a slasher or is not a part of governance\n  error OnlySlasher();\n\n  /// @notice Throws if the msg.sender is not a disputer or is not a part of governance\n  error OnlyDisputer();\n\n  // Methods\n\n  /// @notice Registers a slasher by updating the slashers mapping\n  function addSlasher(address _slasher) external;\n\n  /// @notice Removes a slasher by updating the slashers mapping\n  function removeSlasher(address _slasher) external;\n\n  /// @notice Registers a disputer by updating the disputers mapping\n  function addDisputer(address _disputer) external;\n\n  /// @notice Removes a disputer by updating the disputers mapping\n  function removeDisputer(address _disputer) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}